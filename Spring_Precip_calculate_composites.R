## Visualisations of extreme heatwaves generated by analogue based importance sampling
## Par Pascal Yiou (LSCE), Jan. 2019

  Rsource="/Users/peterpfleiderer/Projects/analogues/scripts/"
  NCEPdir="/Users/peterpfleiderer/Projects/analogues/Data/"
  OUTdir="/Users/peterpfleiderer/Projects/analogues/"

setwd("/Users/peterpfleiderer/Projects/analogues/")
  

## Circulation reanalyses datasets (SLP, Z500, Z500 detrended)
## SLP: slp.1948-2018_NA.nc
## Z500: hgt.1948-2018_NA.nc
## Z500 detrended: base_z500_1950-01-01_2018-12-31_-80.0_50.0_20.0_70.0.nc
library(ncdf4)

source("scripts/readextranc.R")
source("scripts/imagecont.R")
source("scripts/contour_maps_pascal.R")

## Simulations
filesim="rr-m4d1nDay122_cal0.5_precip_0.5_N1000-aggregNcum5-precipAprJul.Rdat"
varname="rr"

## Data recuperation  
filin = paste(NCEPdir,"slp.1948-2018_NA.nc",sep="")
varana = "slp"

## Circulation
nc = nc_open(filin)
datNCEP=lirevarnc(nc,varana)
dat.NCEP.dum=sousseasmean(datNCEP$dat,datNCEP$conv.time,l.year=c(1970:1999))
datNCEP$anom=dat.NCEP.dum$anom
datNCEP$seascyc=dat.NCEP.dum$seascyc
nc_close(nc)

## Temperature
 #this can be replaced with other variable names.
filin = paste(NCEPdir,varname,"_FR_mean.nc",sep="")
nc = nc_open(filin)
varnc=nc$var[[varname]]
## Treatment of time
nctime = nc$dim[['time']]
time=nctime$vals
conv.time=caldat(time+julday(1,1,1950))
years=conv.time$year
months=conv.time$month
days=conv.time$day
varIN_day=ncvar_get(nc,varid=varnc)
nc_close(nc)
Date=10000*years+100*months+days

varIN=data.frame(Date,varIN_day)
## CSeasonal cycle calculation
mmdd = varIN$Date %% 10000


##for(filin in list.in){
print(paste("Processing",filesim))
load(paste('sim_data/',filesim,sep=''))
    
print(args_tmp)

varname = args_tmp[1] ## args_tmp is written with load(filin)!
Lsim =as.integer(args_tmp[2])
mo.start =as.integer(args_tmp[3])
day.start =as.integer(args_tmp[4])
nsim =as.integer(args_tmp[5])
yymin=as.integer(args_tmp[6])
yymax=as.integer(args_tmp[7])
jobid=args_tmp[9]

yy=yymin:yymax
    
## Seasonal cycle calculation
varIN.seascyc = tapply(varIN[[2]],mmdd,mean,na.rm=TRUE)

## First day of the season
idum=which(names(varIN.seascyc) == as.character(mo.start*100+1))

varIN.sum.sort=sort(unlist(simu.dyn$l.varIN.mean),
                  decreasing=TRUE,index.return=TRUE)
nyear = length(simu.dyn$l.T.mean)
## Special years selection:
## hottest, coldest, median and 2018
## If the hottest summer is 2018, show the second hottest
y1=ifelse(yy[varIN.sum.sort$ix[1]]==2015,2,1)
l.yref=c(2016, yy[unlist(simu.sta$l.varIN.mean) == min(unlist(simu.sta$l.varIN.mean))], yy[unlist(simu.sta$l.varIN.mean) == median(unlist(simu.sta$l.varIN.mean))], yy[unlist(simu.sta$l.varIN.mean) == max(unlist(simu.sta$l.varIN.mean))] )
    
## Composites of SLP for year special year
SLP.lref.mean=c()
SLP.lref.std=c()
for(y in l.yref){
    ddum1=y*10000+0401
    ddum2=y*10000+0731
    SLP.lref.mean=cbind(SLP.lref.mean,apply(datNCEP$anom[datNCEP$time >= ddum1 & datNCEP$time <= ddum2,],2,mean))
    SLP.lref.std=cbind(SLP.lref.std,apply(datNCEP$anom[datNCEP$time >= ddum1 & datNCEP$time <= ddum2,],2,sd))
}

### Composites of SLP for the dynamical simulations,
###for each l.ref
#SLP.lref.dyn=c()
#for(y in l.yref){
#  sy=as.character(y)
#  SLP.dum=c()
#  for(i in 1:nsim){
#    d.ref=simu.dyn$l.X[[sy]][[i]][,1]
#    dum = apply(datNCEP$anom[datNCEP$time %in% d.ref,],2,mean)
#    SLP.dum=cbind(SLP.dum,dum)
#  }
#  SLP.lref.dyn=cbind(SLP.lref.dyn,apply(SLP.dum,1,mean))
#}

## Composites of SLP for the dynamical simulations,
SLP.lref.dyn.mean=c()
SLP.lref.dyn.std=c()
for(y in l.yref){
  sy=as.character(y)
  SLP.lref.dyn.mean_loc = c()
  SLP.lref.dyn.std_loc = c()
  dates=c()
  for(i in 1:1000){
    dates_loc = c()
    for(t in simu.dyn$l.X[[sy]][[i]][,1]){
      dates = cbind(dates,which(datNCEP$time==t))
      dates_loc = cbind(dates_loc,which(datNCEP$time==t))
    }
    SLP.lref.dyn.std_loc = cbind(SLP.lref.dyn.std_loc, apply(datNCEP$anom[dates_loc,],2,sd))
    SLP.lref.dyn.mean_loc = cbind(SLP.lref.dyn.mean_loc, apply(datNCEP$anom[dates_loc,],2,mean))
  }
  SLP.lref.dyn.mean=cbind(SLP.lref.dyn.mean,apply(SLP.lref.dyn.mean_loc,1,mean))
  SLP.lref.dyn.std=cbind(SLP.lref.dyn.std,apply(SLP.lref.dyn.std_loc,1,mean))
}
    
## Composites of SLP for the staamical simulations,
SLP.lref.sta.mean=c()
SLP.lref.sta.std=c()
for(y in l.yref){
  sy=as.character(y)
  SLP.lref.sta.mean_loc = c()
  SLP.lref.sta.std_loc = c()
  dates=c()
  for(i in 1:1000){
    dates_loc = c()
    for(t in simu.sta$l.X[[sy]][[i]][,1]){
      dates = cbind(dates,which(datNCEP$time==t))
      dates_loc = cbind(dates_loc,which(datNCEP$time==t))
    }
    SLP.lref.sta.std_loc = cbind(SLP.lref.sta.std_loc, apply(datNCEP$anom[dates_loc,],2,sd))
    SLP.lref.sta.mean_loc = cbind(SLP.lref.sta.mean_loc, apply(datNCEP$anom[dates_loc,],2,mean))
  }
  SLP.lref.sta.mean=cbind(SLP.lref.sta.mean,apply(SLP.lref.sta.mean_loc,1,mean))
  SLP.lref.sta.std=cbind(SLP.lref.sta.std,apply(SLP.lref.sta.std_loc,1,mean))
}

quantile(d.freq['Freq'][,1],c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1))
    
ZZ=unlist(simu.sta$l.varIN.mean)
XX=unlist(lapply(simu.sta$l.X.mean,median))
YY=unlist(lapply(simu.dyn$l.X.mean,median))
#correlation between the normal time series, and the simulated time series
#static simulations
cor.test(XX,ZZ)
#dynamic simulation
cor.test(YY,ZZ)

save.image(file=paste(OUTdir,'plots/',gsub('.Rdat','_prepd.Rdat',filesim),sep=""))



